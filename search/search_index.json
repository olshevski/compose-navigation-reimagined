{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>A small and simple, yet fully fledged and customizable navigation library for Jetpack Compose:</p> <ul> <li>Full type-safety</li> <li>Built-in state restoration</li> <li>Nested navigation with independent backstacks</li> <li>Own Lifecycle, ViewModelStore and SavedStateRegistry for every backstack entry</li> <li>Animated transitions</li> <li>Dialog and bottom sheet navigation</li> <li>Scopes for easier ViewModel sharing </li> <li>No builders, no obligatory superclasses for your composables</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<p>Add a single dependency to your project:</p> <pre><code>implementation(\"dev.olshevski.navigation:reimagined:1.5.0\")\n</code></pre> <p>Define a set of destinations. It is convenient to use a sealed class for this:</p> <pre><code>sealed class Destination : Parcelable {\n\n    @Parcelize\n    data object First : Destination()\n\n    @Parcelize\n    data class Second(val id: Int) : Destination()\n\n    @Parcelize\n    data class Third(val text: String) : Destination()\n\n}\n</code></pre> <p>Create a composable with <code>NavController</code>, <code>NavBackHandler</code> and <code>NavHost</code>:</p> <pre><code>@Composable\nfun NavHostScreen() {\n    val navController = rememberNavController&lt;Destination&gt;(\n        startDestination = Destination.First\n    )\n\n    NavBackHandler(navController)\n\n    NavHost(navController) { destination -&gt;\n        when (destination) {\n            is Destination.First -&gt; Column {\n                Text(\"First destination\")\n                Button(onClick = {\n                    navController.navigate(Destination.Second(id = 42))\n                }) {\n                    Text(\"Open Second destination\")\n                }\n            }\n\n            is Destination.Second -&gt; Column {\n                Text(\"Second destination: ${destination.id}\")\n                Button(onClick = {\n                    navController.navigate(Destination.Third(text = \"Hello\"))\n                }) {\n                    Text(\"Open Third destination\")\n                }\n            }\n\n            is Destination.Third -&gt; {\n                Text(\"Third destination: ${destination.text}\")\n            }\n        }\n    }\n}\n</code></pre> <p>As you can see, <code>NavController</code> is used for switching between destinations, <code>NavBackHandler</code> handles back presses and <code>NavHost</code> provides a composable corresponding to the last destination in the backstack. As simple as that.</p>"},{"location":"animations/","title":"Animations","text":"<p>If you want to show animated transitions between destinations use AnimatedNavHost. The default transition is a simple crossfade, but you can granularly customize every transition with your own <code>NavTransitionSpec</code> implementation.</p> <p>Here is one possible implementation of NavTransitionSpec:</p> <pre><code>val CustomTransitionSpec = NavTransitionSpec&lt;Any?&gt; { action, _, _ -&gt;\n    val direction = if (action == NavAction.Pop) {\n        AnimatedContentTransitionScope.SlideDirection.End\n    } else {\n        AnimatedContentTransitionScope.SlideDirection.Start\n    }\n    slideIntoContainer(direction) togetherWith slideOutOfContainer(direction)\n}\n</code></pre> <p>Set it into AnimatedNavHost:</p> <pre><code>AnimatedNavHost(\n    controller = navController,\n    transitionSpec = CustomTransitionSpec\n) { destination -&gt;\n    // ...\n}\n</code></pre> <p>and it'll end up looking like this:</p> <p> </p> <p>In NavTransitionSpec you get the parameters:</p> <ul> <li><code>action</code> - a hint about the last NavController method that changed the backstack</li> <li><code>from</code> - a previous visible destination</li> <li><code>to</code> - a target visible destination</li> </ul> <p>This information is plenty enough to choose a transition for every possible combination of destinations and navigation actions.</p> <p>Tip</p> <p>You can add more enter/exit animations to the composables through the <code>AnimatedNavHostScope</code> receiver of the <code>contentSelector</code> parameter. AnimatedNavHostScope gives you access to the current <code>transition</code> and to <code>animateEnterExit</code> modifier.</p>"},{"location":"animations/#navaction","title":"NavAction","text":"<p>There are four default NavAction types:</p> <ul> <li><code>Pop</code>, <code>Replace</code> and <code>Navigate</code> - objects that correspond to <code>pop\u2026</code>, <code>replace\u2026</code>, <code>navigate</code> methods of NavController</li> <li><code>Idle</code> - the default action of a newly created NavController. You don't need to handle it in NavTransitionSpec.</li> </ul> <p>You can also create new action types by implementing <code>NavAction</code> interface. Pass any object of the new type into <code>setNewBackstack</code> method of NavController and handle it in NavTransitionSpec.</p> <p>The last action can also be accessed through <code>action</code> property of NavBackstack.</p>"},{"location":"back-handling/","title":"Back handling","text":"<p>Back handling in the library is opt-in, rather than opt-out. By itself, neither NavController nor NavHost handles the back button press. You can add <code>NavBackHandler</code> or usual <code>BackHandler</code> in order to react to back presses where you need to.</p> <p>NavBackHandler is the most basic implementation of BackHandler - it calls <code>pop</code> only when there are more than one item in the backstack. When there is only one backstack item left, NavBackHandler is disabled, and any upper-level BackHandler may take its turn to react to back button presses.</p> <p>If you want to specify your own backstack logic, use BackHandler directly. For example, this is how back navigation is handled for BottomNavigation in the sample:</p> <pre><code>@Composable\nprivate fun BottomNavigationBackHandler(\n    navController: NavController&lt;BottomNavigationDestination&gt;\n) {\n    BackHandler(enabled = navController.backstack.entries.size &gt; 1) {\n        val lastEntry = navController.backstack.entries.last()\n        if (lastEntry.destination == BottomNavigationDestination.values()[0]) {\n            // The start destination should always be the last to pop. We move\n            // it to the start to preserve its saved state and view models.\n            navController.moveLastEntryToStart()\n        } else {\n            navController.pop()\n        }\n    }\n}\n</code></pre> <p>Bug</p> <p>Always place your NavBackHandler/BackHandler before the corresponding NavHost.</p> <p>As both BackHandler and NavHost use Lifecycle under the hood, there is a case when the order of back handling may be restored incorrectly after process/activity recreation. This is how the framework works and there is nothing to do about it. Simple placement of BackHandler before NavHost guarantees no issues in this part.</p>"},{"location":"bottom-sheets/","title":"Bottom sheets","text":"<p>Similar to dialogs, you may use BottomSheetNavHost to handle a backstack of bottom sheets alongside the backstack of screens.</p> <p> </p> <p>To use it, you need to add the dependency:</p> <pre><code>// if you are using Material\nimplementation(\"dev.olshevski.navigation:reimagined-material:&lt;latest-version&gt;\")\n\n// if you are using Material 3\nimplementation(\"dev.olshevski.navigation:reimagined-material3:&lt;latest-version&gt;\")\n</code></pre> <p>The usage would look like this:</p> <pre><code>@Composable\nfun NavHostScreen() {\n    val navController = rememberNavController&lt;ScreenDestination&gt;(\n        startDestination = ScreenDestination.First,\n    )\n\n    val sheetController = rememberNavController&lt;SheetDestination&gt;(\n        initialBackstack = emptyList()\n    )\n\n    NavBackHandler(navController)\n\n    NavHost(navController) { destination -&gt;\n        when (destination) {\n            ScreenDestination.First -&gt; { /* ... */ }\n            ScreenDestination.Second -&gt; { /* ... */ }\n        }\n    }\n\n    NavBackHandler(\n        controller = sheetController,\n        allowEmptyBackstack = true\n    )\n\n    BottomSheetNavHost(\n        controller = sheetController,\n        onDismissRequest = { sheetController.pop() }\n    ) { destination -&gt;\n        Surface(\n            elevation = ModalBottomSheetDefaults.Elevation\n        ) {\n            when (destination) {\n                SheetDestination.First -&gt; { /* ... */ }\n                SheetDestination.Second -&gt; { /* ... */ }\n            }\n        }\n    }\n}\n</code></pre> <p>BottomSheetNavHost is based on the source code of ModalBottomSheetLayout, but with some improvements for switching between multiple bottom sheets. The API also has some similarities.</p> <p>Tip</p> <p>You can access current <code>sheetState</code> through the <code>BottomSheetNavHostScope</code> receiver of the <code>contentSelector</code> parameter.</p>"},{"location":"dialogs/","title":"Dialogs","text":"<p>If you need to handle a backstack of dialogs in your application, simply add DialogNavHost to the same composition layer where your regular NavHost lives. This way you may show and control the backstack of regular screen destinations, as well as a second backstack of dialogs:</p> <pre><code>@Composable\nfun NavHostScreen() {\n    val navController = rememberNavController&lt;ScreenDestination&gt;(\n        startDestination = ScreenDestination.First,\n    )\n\n    val dialogController = rememberNavController&lt;DialogDestination&gt;(\n        initialBackstack = emptyList()\n    )\n\n    NavBackHandler(navController)\n\n    NavHost(navController) { destination -&gt;\n        when (destination) {\n            ScreenDestination.First -&gt; { /* ... */ }\n            ScreenDestination.Second -&gt; { /* ... */ }\n        }\n    }\n\n    DialogNavHost(dialogController) { destination -&gt;\n        Dialog(onDismissRequest = { dialogController.pop() }) {\n            when (destination) {\n                DialogDestination.First -&gt; { /* ... */ }\n                DialogDestination.Second -&gt; { /* ... */ }\n            }\n        }\n    }\n}\n</code></pre> <p>DialogNavHost is an alternative version of NavHost that is better suited for showing dialogs. It is based on AnimatedNavHost and provides smoother transition between dialogs without scrim flickering:</p> <p> </p> <p>And this is how it looks in the regular NavHost:</p> <p> </p> <p>Note</p> <p>DialogNavHost doesn't wrap your composables into a Dialog. You need to use either Dialog or AlertDialog composable inside <code>contentSelector</code> yourself.</p>"},{"location":"nav-controller/","title":"NavController","text":"<p>This is the main control point of navigation. It keeps record of all current backstack entries and preserves them on activity/process recreation.</p> <p>NavController may be created with <code>rememberNavController</code> method in a composable function or with <code>navController</code> outside of composition. The latter may be used for storing NavController in a ViewModel. As it implements Parcelable interface, it could be stored in a SavedStateHandle.</p> <p>Both <code>rememberNavController</code> and <code>navController</code> methods accept <code>startDestination</code> as a parameter:</p> <pre><code>val navController = rememberNavController&lt;Destination&gt;(\n    startDestination = Destination.First\n)\n</code></pre> <p>If you want to create NavController with an arbitrary number of backstack items, you may use <code>initialBackstack</code> parameter instead:</p> <pre><code>val navController = rememberNavController&lt;Destination&gt;(\n    initialBackstack = listOf(Destination.First, Destination.Second, Destination.Third)\n)\n</code></pre> <p><code>Destination.Third</code> will become the currently displayed item. <code>Destination.First</code> and <code>Destination.Second</code> will be stored in the backstack.</p> <p>If you want to store NavController in a ViewModel use <code>saveable</code> delegate for SavedStateHandle:</p> <pre><code>class NavigationViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {\n\n    val navController by savedStateHandle.saveable&lt;NavController&lt;Destination&gt;&gt; {\n        navController(startDestination = Destination.First)\n    }\n\n}\n</code></pre>"},{"location":"nav-controller/#destinations","title":"Destinations","text":"<p>NavController accepts all types that meet the requirements as destinations:</p> <ol> <li> <p>The type must be writable to Parcel - it could be Parcelable, Serializable, string/primitive, or other supported type.</p> </li> <li> <p>The type must be Stable, Immutable, or string/primitive type.</p> </li> </ol> <p>Other than that, you are not limited to any particular type.</p> <p>Tip</p> <p>It is very convenient to define your set of destinations as a sealed class or enum. This way you will always be notified by the compiler that you have a non-exhaustive <code>when</code> statement if you add a new destination.</p> <p>Tip</p> <p>You may also define your own base interface for destinations, for example:</p> <pre><code>interface Destination : Parcelable {\n\n    @Composable\n    fun Content()\n\n}\n</code></pre> <p>This way you may handle each destinations without checking its instance:</p> <pre><code>NavHost(navController) { it.Content() }\n</code></pre>"},{"location":"nav-controller/#naventry","title":"NavEntry","text":"<p>In order to be passed into NavController, each destination should be wrapped into NavEntry. It contains a unique identifier which is used to properly preserve saved state and manage Android architecture components (Lifecycle, ViewModelStore and SavedStateRegistry) for each such entry inside NavHost.</p> <p>Saved state and view models of each entry are guaranteed to be preserved for as long as the associated entry is present in the backstack.</p> <p>Note</p> <p>If you add two equal destinations to the backstack, wrapped into two different entries, they will get their own separate identities, saved states and components. However, it is possible to put same exact entry instance into the backstack and it will be correctly treated as the same entry.</p>"},{"location":"nav-controller/#navigation-methods","title":"Navigation methods","text":"<p>There is a handful of pre-defined methods suitable for basic app navigation: <code>navigate</code>, <code>moveToTop</code>, <code>pop</code>, <code>popUpTo</code>, <code>popAll</code>, <code>replaceLast</code>, <code>replaceUpTo</code>, <code>replaceAll</code>. They all are pretty much self-explanatory, except maybe <code>moveToTop</code>.</p> <p><code>moveToTop</code> method searches for some particular destination in the backstack and moves it to the top, effectively making it the currently displayed destination. This is particularly useful for integration with BottomNavigation/TabRow, when you want to always keep a single instance of every destination in the backstack.</p> <p>The method is expected to be used in pair with <code>navigate</code>:</p> <pre><code>if (!navController.moveToTop { it is SomeDestination }) {\n    // navigate to a new destination if there is no existing one\n    navController.navigate(SomeDestination())\n}\n</code></pre> <p>You may see how it is used for BottomNavigation in the sample.</p>"},{"location":"nav-controller/#methods-with-a-search-predicate","title":"Methods with a search predicate","text":"<p><code>moveToTop</code>, <code>popUpTo</code>, <code>replaceUpTo</code> methods require the <code>predicate</code> parameter to be specified. It provides a selection condition for a destination to search for.</p> <p>In case multiple destinations match the predicate, you may specify the <code>match</code> parameter. <code>Match.Last</code> is the default value and in this case the last matching item from the start of the backstack will be selected. Alternatively, you may use <code>Match.First</code>.</p>"},{"location":"nav-controller/#new-custom-methods","title":"New custom methods","text":"<p>If your use-case calls for some advanced backstack manipulations, you may use <code>setNewBackstack</code> method. It is in fact the only public method defined in NavController, all other methods are provided as extensions and use <code>setNewBackstack</code> under the hood. Here is how a new extension method <code>moveLastEntryToStart</code> is implemented in the sample:</p> <pre><code>fun NavController&lt;BottomNavigationDestination&gt;.moveLastEntryToStart() {\n    setNewBackstack(\n        entries = backstack.entries.toMutableList().also {\n            val entry = it.removeLast()\n            it.add(0, entry)\n        },\n        action = NavAction.Pop\n    )\n}\n</code></pre>"},{"location":"nav-controller/#navbackstack","title":"NavBackstack","text":"<p>You may access current backstack entries and the last NavAction through <code>backstack</code> property of NavController. This property is backed up by MutableState and any changes to it will notify composition.</p>"},{"location":"nav-host/","title":"NavHost","text":"<p>NavHost is a composable that shows the last entry of a backstack, manages saved state and provides all Android architecture components associated with the entry: Lifecycle, ViewModelStore and SavedStateRegistry. All these components are provided through CompositionLocalProvider within their corresponding owners: <code>LocalLifecycleOwner</code>, <code>LocalViewModelStoreOwner</code> and <code>LocalSavedStateRegistryOwner</code>.</p> <p>The components are kept around until its associated entry is removed from the backstack (or until the parent entry containing the current child NavHost is removed).</p> <p>The default NavHost implementation by itself doesn't provide any animated transitions, it simply jump-cuts to the next destination:</p> <p> </p>"},{"location":"nav-host/#navhostentry-and-navhostscope","title":"NavHostEntry and NavHostScope","text":"<p>Each NavEntry from the backstack is mapped to NavHostEntry within NavHost. NavHostEntry is what actually implements <code>LifecycleOwner</code>, <code>SavedStateRegistryOwner</code> and <code>ViewModelStoreOwner</code> interfaces.</p> <p>Usually, you don't need to interact with NavHostEntries directly, everything just works out of the box. But if you have a situation when you need to access all NavHostEntries from the current backstack, e.g. trying to access a ViewModel of neighbour entry, you could do it through the <code>NavHostScope</code> receiver of the <code>contentSelector</code> parameter.</p>"},{"location":"nav-host/#navhoststate","title":"NavHostState","text":"<p>NavHostState is a state holder of NavHost that stores and manages saved state and all Android architecture components for each entry. By default, it is automatically created by NavHost, but it is possible to create and set it into NavHost manually.</p> <p>Note that you most probably don't need to use the state holder directly unless you are conditionally adding/removing NavHost to/from composition:</p> <pre><code>val state = rememberNavHostState(backstack)\nif (visible) {\n     NavHost(state) {\n         // ...\n     }\n}\n</code></pre> <p>In this example, the state of NavHost will be properly preserved, as it is placed outside of condition.</p> <p>If you do want to clear the state when NavHost is removed by condition, use <code>NavHostVisibility</code>/<code>NavHostAnimatedVisibility</code>. These composables properly clear the internal state of NavHost when the <code>visible</code> parameter is set to <code>false</code>:</p> <pre><code>NavHostVisibility(visible) {\n    NavHost(backstack) {\n        // ...\n    }\n}\n</code></pre> <p>You can explore the sample of NavHostVisibility usage here.</p>"},{"location":"nested-navigation/","title":"Nested navigation","text":"<p>Nested navigation is actually quite simple. You just need to place NavHost (let's call it a child) into any entry of the other NavHost (a parent). You may want to add decoration around your child NavHost or leave it within the same viewport of the parent NavHost.</p> <p> </p> <p>There may be different reasons for nesting your NavHosts:</p> <ul> <li> <p>It may be useful when you need to have several backstacks at once, as in case of BottomNavigation, TabRow, or similar, where each item has it's own inner independent layer of navigation.</p> </li> <li> <p>You want to contain some particular flow of destinations within a single composable function. This flow may also contain some shared static layout elements. </p> </li> <li> <p>You want to share a ViewModel between several destinations that logically and visually may be grouped into a single flow.</p> </li> </ul> <p>Note</p> <p>There is no depth limit for nesting NavHosts. In fact, each NavHost is completely oblivious to its placement in the hierarchy.</p>"},{"location":"return-results/","title":"Return results","text":"<p>As destination types are not strictly required to be Immutable, you may change them while they are in the backstack. This may be used for returning values from other destinations. Just make a mutable property backed up by <code>mutableStateOf</code> and change it when required.</p> <p>For example, we want to return a string from the Second screen. Here is how destinations may be defined:</p> <pre><code>interface AcceptsResultFromSecond {\n    val resultFromSecond: MutableState&lt;String?&gt;\n}\n\n@Stable\nsealed class Destination : Parcelable {\n\n    @Parcelize\n    data class First(\n        override val resultFromSecond: @RawValue MutableState&lt;String?&gt; = mutableStateOf(null)\n    ) : Destination(), AcceptsResultFromSecond\n\n    @Parcelize\n    data object Second : Destination()\n\n}\n</code></pre> <p>And to actually set the result from the Second screen you do:</p> <pre><code>val previousDestination = navController.backstack.entries.let {\n    it[it.lastIndex - 1].destination\n}\ncheck(previousDestination is AcceptsResultFromSecond)\npreviousDestination.resultFromSecond.value = text\nnavController.pop()\n</code></pre> <p>You may see how it is implemented in the sample here.</p> <p>Warning</p> <p>In general, returning values to previous destinations makes the navigation logic more complicated. Also, this approach doesn't guarantee full compile time type-safety. Use it with caution and when you are sure what you are doing. Sometimes it may be easier to use a shared state holder. </p>"},{"location":"shared-view-models/","title":"Shared ViewModels","text":"<p>Sometimes you need to access the same ViewModel instance from several destinations. The library provides multiple ways to achieve this.</p>"},{"location":"shared-view-models/#nested-navigation","title":"Nested navigation","text":"<p>The easiest way to share a ViewModel between several destinations is to use a nested NavHost. Simply collect all required destinations into a separate nested NavHost, and pass a ViewModel of the parent entry to each destination.</p> <p>However, it may not work for all scenarios. Sometimes it is not desirable or possible to group destinations into a single nested NavHost. For such cases, it would be more convenient to use scoping NavHosts.</p>"},{"location":"shared-view-models/#scoping-navhosts","title":"Scoping NavHosts","text":"<p>Each NavHost in the library has its own <code>Scoping</code> counterpart. For <code>NavHost</code> it is <code>ScopingNavHost</code>, for <code>AnimatedNavHost</code> it is <code>ScopingAnimatedNavHost</code>, and so on.</p> <p>Every scoping NavHost gives you the ability to assign scopes to destinations and access scoped ViewModelStoreOwners bound to each of the defined scope. Such scoped ViewModelStoreOwner is created when there is at least one backstack entry marked with the corresponding scope, and removed when there are none of the entries marked with it.</p> <p>For example, the ViewModelStoreOwner for Scope X will exist only when at least one of the destinations B or C is in the backstack (their positions don't matter). Both B and C can access the same ViewModelStoreOwner instance. A cannot access it as it is not marked with Scope X.</p> <p> </p> <p>When both B and C are popped off the backstack and there is only A left, the ViewModelStoreOwner for Scope X will be cleared and removed.</p> <p> </p> <p>Note that if you replace B and C with a new destination D that is also marked with Scope X, the ViewModelStoreOwner will not be recreated, but left as is.</p> <p> </p> <p>In order to use scoping NavHost, you need to implement <code>NavScopeSpec</code> and pass it as the <code>scopeSpec</code> parameter. <code>NavScopeSpec</code> requests a set of scopes for each destination in the backstack:</p> <pre><code>@Parcelize\ndata object ScopeX : Parcelable\n\nval DestinationScopeSpec = NavScopeSpec&lt;Destination, ScopeX&gt; { destination -&gt;  \n    when (destination) {\n        Destination.B, Destination.C, Destination.D -&gt; setOf(ScopeX)\n        else -&gt; emptySet()\n    }\n}\n</code></pre> <p>Note that a destination may belong to several scopes at once, that's why NavScopeSpec requires you to return a <code>Set</code>.</p> <p>Scoped ViewModelStoreOwner is implemented by <code>ScopedNavHostEntry</code> class. You can acquire all scoped entries associated with the current destination through the <code>ScopingNavHostScope</code> receiver of the <code>contentSelector</code> parameter:</p> <pre><code>ScopingNavHost(\n    controller = navController,\n    scopeSpec = DestinationScopeSpec\n) { destination -&gt;\n    when (destination) {\n        Destination.A -&gt; { /* ... */ }\n        Destination.B -&gt; {\n            val sharedViewModel = viewModel&lt;SharedViewModel&gt;(\n                viewModelStoreOwner = scopedHostEntries[ScopeX]!!\n            )\n        }\n        Destination.C -&gt; { /* same code as for B */ }\n        Destination.D -&gt; { /* same code as for B */ }\n    }\n}\n</code></pre> <p>You just have to pass this ScopedNavHostEntry as the <code>viewModelStoreOwner</code> parameter of the <code>viewModel</code> method.</p> <p>Alternatively, you can access scoped ViewModelStoreOwners through the <code>LocalScopedViewModelStoreOwners</code> composition local.</p>"},{"location":"shared-view-models/#access-viewmodels-of-backstack-entries","title":"Access ViewModels of backstack entries","text":"<p>If the two previous solutions are not suitable for your case, you may always access ViewModels of neighbour entries directly. Read more about it here.</p>"},{"location":"view-models/","title":"Entry-scoped ViewModels","text":"<p>Every unique NavEntry in NavHost provides its own ViewModelStore. Every such ViewModelStore is guaranteed to exist for as long as the associated NavEntry is present in the backstack.</p> <p>As soon as NavEntry is removed from the backstack, its ViewModelStore with all ViewModels is cleared.</p> <p>You can get ViewModels as you do it usually, by using composable <code>viewModel</code> from <code>androidx.lifecycle:lifecycle-viewmodel-compose</code> artifact, for example:</p> <pre><code>@Composable\nfun SomeScreen() {\n    val someViewModel = viewModel&lt;SomeViewModel&gt;()\n    // ...\n}\n</code></pre>"},{"location":"view-models/#accessing-viewmodels-of-backstack-entries","title":"Accessing ViewModels of backstack entries","text":"<p>It is possible to access ViewModelStoreOwner of any entry that is currently present on the backstack. It is done through the the <code>NavHostScope</code> receiver of the <code>contentSelector</code> parameter of NavHost:</p> <pre><code>@Composable\nfun NavHostScope&lt;Destination&gt;.SomeScreen() {\n    val previousViewModel = viewModel&lt;PreviousViewModel&gt;(\n        viewModelStoreOwner = hostEntries.find {\n            it.destination is Destination.Previous\n        }!!\n    )\n    // ...\n}\n</code></pre>"},{"location":"view-models/#passing-parameters-into-a-viewmodel","title":"Passing parameters into a ViewModel","text":"<p>There is no such thing as a Bundle of arguments for navigation entries in this library. This means that there is literally nothing to pass into <code>SavedStateHandle</code> of your ViewModel as the default arguments.</p> <p>I personally recommend passing all parameters into a ViewModel constructor directly. This keeps everything clean and type-safe.</p> <p>If you use dependency injections in your project, explore the samples that show how to pass parameters into a ViewModel and inject all other dependencies:</p> <ul> <li> <p>Dagger/Anvil/Hilt use @AssistedInject</p> </li> <li> <p>Koin supports ViewModel parameters out of the box and does it charmingly simple</p> </li> </ul>"},{"location":"view-models/#hiltviewmodel","title":"hiltViewModel()","text":"<p>If Hilt is the DI library of your choice and you want to use <code>hiltViewModel()</code> method that you may already be familiar with from the official Navigation Component, you can add the dependency:</p> <pre><code>implementation(\"dev.olshevski.navigation:reimagined-hilt:&lt;latest-version&gt;\")\n</code></pre> <p>It provides a similar <code>hiltViewModel()</code> method that works with the Reimagined library. The only catch is that by default it doesn't know how to pass arguments to the SavedStateHandle of your ViewModel. For this you can use an additional <code>defaultArguments</code> parameter:</p> <pre><code>val viewModel = hiltViewModel&lt;SomeViewModel&gt;(\n    defaultArguments = bundleOf(\"id\" to id)\n)\n</code></pre> <p>And in ViewModel you can read this argument as such:</p> <pre><code>@HiltViewModel\nclass SomeViewModel @Inject constructor(\n    savedStateHandle: SavedStateHandle\n) : LoggingViewModel() {\n\n    private val id: Int = savedStateHandle[\"id\"]!!\n\n}\n</code></pre> <p>Tip</p> <p>Don't forget to annotate your view models with <code>@HiltViewModel</code> annotation.</p> <p>Warning</p> <p>Do not pass mutable data structures as <code>defaultArguments</code> and expect the external changes to be reflected through the SavedStateHandle inside a ViewModel, e.g. when trying to return results as described here.</p> <p>As soon as SavedStateHandle parcelize/unparcelize data once, it becomes the only source of truth for the data it holds.</p> <p>If you still need to pass mutable data structure into your ViewModel, it would be more reliable to pass it directly as a constructor parameter).</p>"}]}